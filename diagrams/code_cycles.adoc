:backend: revealjs
:revealjs_theme: white
:customcss: common.css
:revealjs_transition: none

=== Сборка jar-file
["graphviz", "code_cycle", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Jenkins[label="code"];
  Jenkins -> Artifactory[label="jar-file"];
}
---------------------------------------------------------------------

[.notes]
--
Как я уже сказал, большая часть наших сервисов работает на java. Чтобы java задеплоить - 
надо сначала ее собрать. А чтобы она не болталась на сборщике, надо положить ее в
хранилище артефактов, откуда с ней потом будет легко взаимодействовать. Схема простая,
знакомая всем инженерам, не будем на ней задерживаться.
--

=== Сборка docker-образа
["graphviz", "image_cycle", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Jenkins[label="code"];
  Artifactory -> Jenkins[label="jar-file"];
  Jenkins -> Artifactory[label="docker-image"];
}
---------------------------------------------------------------------

[.notes]
--
А вот тут уже чуть поинтереснее, но на самом деле не очень. Уже только ленивый не использует докер
в продакшене, и мы отставать от этой тенденции не собирались. Даешь продакшен на контейнерах.
--

=== Я рассажу вас по стульчикам
image::images/before_k8s_after_k8s.jpg[]

=== Почему docker/kubernetes?
[%step]
* Урезать рацион
* Легко масштабировать
* Упал - перезапустился
* Изоляция окружения
* Собственная межсервисная сеть и dns

[.notes]
--
Ладно, пару слов докеру все же посвятим. Причины, по которым мы отказались от создания классических
виртуальных машин.
Первое - мы лишаем приложение операционной системы. То есть в отношении классических дроплетов урезаем
цену в несколько раз.
Второе - действительно легкое масштабирование. Я могу понять 10, 20 контейнеров, каждый будет
выполнять свою задачу. Если для задачи нужен всего один контейнер, или вообще не нужен - ничего не мешает
его заглушить, и только его образ будет храниться у меня на кластере.
Третье - после падения контейнер можно легко перезапустить, и это будет свежее приложение, которое проработает
до нового падения. Более того, процесс перезапуска контейнеров легко автоматизируется.
Четвертое - изолированное окружение. Со всеми зависимостями и необходимыми для запуска вещами контейнер может
исполняться независимо от того, установлена ли та же джава на хост-машине, и той ли она версии.
Пятое - собственная межсервисная сеть и dns. Контейнеры резолвят друг друга без всякой дополнительной настройки.
Даешь сервис-дискавери из коробки.
--

=== Почему ОБЛАЧНЫЙ kubernetes?
[%step]
* Легко свернуть-развернуть
* K8saaS - это недорого
* У Terraform есть провайдеры, поэтому легко жить с IaC

[.notes]
--

--

=== Упаковка helm-чарта
["graphviz", "chart_cycle", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Jenkins[label="code"];
  Jenkins -> Artifactory[label="chart"]
}
---------------------------------------------------------------------

=== Почему helm?
[%step]
* Пакетный менеджер для сервисов k8s
* Cloud Native Computing Foundation
* Большое количество готовых пакетов для классического web
* Скоро будет Helm 3 без детских болезней(уже есть альфа)
* Достаточно выбрать другой namespace, и будет dev, test, staging, prod

=== Инфраструктура тоже здесь
["graphviz", "infra_cycle", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Atlantis[label="tf"];
  Artifactory -> cloud_provider[label="images, charts"];
  Atlantis -> cloud_provider[label="tf, creds"];
  Atlantis -> Artifactory[label="tfstate"];
}
---------------------------------------------------------------------

=== Atlantis - IaC автоматизация прямо из VCS
image::images/hero.png[]
[.notes]
--
Здесь многие из вас столкнулись с новым словом - Atlantis.
Atlantis - это механизм автоматизации Терраформа. Будучи сервисом,
атлантис слушает вебхуки из VCS, в частности GitHub/GitLab/Bitbucket.
И запускает terraform test при пуллреквесте в инфраструктуру. Таким
образом, технически даже нет необходимости иметь у себя локальный Терраформ,
чтобы управлять инфраструктурой - достаточно сделать пулл-реквест.
--

=== Некосмический корабль
["graphviz", "Atlantis_1", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Atlantis[label="webhook",color=red]
  GitHub -> Atlantis[label="tf-file",color=red]
  GitHub -> Atlantis[label="apply"]
  Atlantis -> cloud_provider[label="infrastructure"]
  Atlantis -> backend[label="tfstate"]
  backend -> Atlantis[label="tfstate"]
  Atlantis -> GitHub[label="output"]
}
---------------------------------------------------------------------

=== Некосмический корабль
["graphviz", "Atlantis_2", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Atlantis[label="webhook"]
  GitHub -> Atlantis[label="tf-file"]
  GitHub -> Atlantis[label="apply"]
  Atlantis -> cloud_provider[label="infrastructure"]
  Atlantis -> backend[label="tfstate"]
  backend -> Atlantis[label="tfstate",color=red]
  Atlantis -> GitHub[label="output",color=red]
}
---------------------------------------------------------------------

=== Некосмический корабль
["graphviz", "Atlantis_3", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Atlantis[label="webhook"]
  GitHub -> Atlantis[label="tf-file"]
  GitHub -> Atlantis[label="apply",color=red]
  Atlantis -> cloud_provider[label="infrastructure"]
  Atlantis -> backend[label="tfstate"]
  backend -> Atlantis[label="tfstate"]
  Atlantis -> GitHub[label="output"]
}
---------------------------------------------------------------------

=== Некосмический корабль
["graphviz", "Atlantis_4", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub -> Atlantis[label="webhook"]
  GitHub -> Atlantis[label="tf-file"]
  Atlantis -> cloud_provider[label="infrastructure",color=red]
  Atlantis -> backend[label="tfstate",color=red]
  GitHub -> Atlantis[label="apply"]
  backend -> Atlantis[label="tfstate"]
  Atlantis -> GitHub[label="output",color=red]
}
---------------------------------------------------------------------

=== Не будем отвлекаться
["graphviz", "all_cycle", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub;
  Atlantis;
  cloud_provider;
  GitHub -> Jenkins[label="code"];
  Jenkins -> Artifactory[label="jar-file"];
  Artifactory -> Jenkins[label="jar-file"];
  Jenkins -> Artifactory[label="image"];
  Jenkins -> Artifactory[label="chart"];
  GitHub -> Atlantis[label="tf"];
  Artifactory -> cloud_provider[label="docker-image, chart"];
  Atlantis -> cloud_provider[label="tf, creds, helm"];
  Atlantis -> Artifactory[label="tfstate"];
}
---------------------------------------------------------------------

=== Не будем отвлекаться
["graphviz", "all_cycle_interest", "svg"]
---------------------------------------------------------------------
digraph main {
  rankdir = LR;
  GitHub[color=blue];
  Atlantis[color=blue];
  cloud_provider[color=blue];
  GitHub -> Jenkins[label="code"];
  Jenkins -> Artifactory[label="jar-file"];
  Artifactory -> Jenkins[label="jar-file"];
  Jenkins -> Artifactory[label="image"];
  Jenkins -> Artifactory[label="chart"];
  GitHub -> Atlantis[label="tf",color=blue];
  Artifactory -> cloud_provider[label="docker-image, chart"];
  Atlantis -> cloud_provider[label="tf, creds, helm",color=blue];
  Atlantis -> Artifactory[label="tfstate"];
}
---------------------------------------------------------------------
