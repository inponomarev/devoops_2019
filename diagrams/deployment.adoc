:backend: revealjs
:revealjs_theme: white
:customcss: common.css
:revealjs_transition: none

== А что, собственно, деплоим?
["graphviz", "main_scheme_joke", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  rankdir = LR;
  source [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled,height=1.5,label="Исходный \nсайт"];
  spectator [shape=polygon,sides=5,peripheries=3,color=orange,style=filled,height=1.5,label="Пользователь"];
  source -> spectator[label="data"];
}
---------------------------------------------------------------------

[.notes]
--
Здесь мы можем наблюдать классическую схему, в которой мы не участвуем. Есть источник данных - некий сайт.
Или 10 сайтов. Или 20. И пользователь может просто зайти на этот сайт, и посмотреть, что там есть.
Клиенту не хочется смотреть на этот сайт самому, клиент собрал свою оболочку, например, табло, и хочетс
максимально оперативно выводить свою информацию на это самое табло. И заказывает у нас систему,
которая будет смотреть на этот сайт, и выдавать нужные клиенту цифры.
--

=== А что, собственно, деплоим?
["graphviz", "main_scheme_1", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  rankdir = LR;
  source [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled,height=1.5,label="Исходный \nсайт"];
  spectator [shape=polygon,sides=5,peripheries=3,color=orange,style=filled,height=1.5,label="Пользователь"];

  source -> service_1;
  service_1 -> redis -> service_1;
  service_2 -> redis -> service_2;
  service_1 -> kafka;
  service_3 -> kafka -> service_3;
  kafka -> service_4 -> spectator;

  subgraph mainline {
    label = "Main line";
    service_1 [shape=diamond];
    service_2 [shape=diamond];
    service_3 [shape=diamond];
    service_4 [shape=diamond];
  }

  subgraph side_services {
    label = "Side services";
    rank = same;
    redis [shape=box]
    kafka [shape=box]
  }
}
---------------------------------------------------------------------

["graphviz", "main_scheme_legend_", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  service [shape=diamond,label="Наши сервисы"];
  side_service [shape=box, label="Сторонние сервисы"];
}
---------------------------------------------------------------------

[.notes]
--
Вот так система начинает выглядеть, когда в нее включаемся мы. Один сервис смотрит на главную
страницу сайта, и выкачивает оттуда информацию о том, что еще не этом сайте есть. Всю полученную
информацию он складывает в редиску. Из редиски эту информацию достает другой сервис, потрошит ее,
и складывает обратно в редиску адреса, по которым находятся интересующие клиента события. Первый сервис
забирает эти адреса и рассматривает их, выгружая большие дозы информации в кафку. Третий сервис, получая
из кафки большое количество сырых данных, перерабатывает их, очищает и возвращает туда же. Теперь у нас
в кафке лежат чистые данные, готовые к употреблению. Ну и наконец, эти самые данные мы отдаем клиенту
через апишечку, по требованию.
--

=== А что, собственно, деплоим?
["graphviz", "main_scheme_2", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  rankdir = LR;
  source [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled,height=1.5,label="Исходный \nсайт"];
  spectator [shape=polygon,sides=5,peripheries=3,color=orange,style=filled,height=1.5,label="Пользователь"];

  source -> service_1;
  service_1 -> redis -> service_1;
  service_2 -> redis -> service_2;
  service_1 -> kafka;
  service_3 -> kafka -> service_3;
  kafka -> service_4;

  service_4 -> ingress;
  ingress -> spectator;

  subgraph mainline {
    label = "Main line";
    service_1 [shape=diamond];
    service_2 [shape=diamond];
    service_3 [shape=diamond];
    service_4 [shape=diamond];
  }

  subgraph side_services {
    label = "Side services";
    rank = same;
    redis [shape=box]
    kafka [shape=box]
  }

  subgraph support {
    label = "Support";
    rank = same;
    dns_manager [shape=box];
    cert_manager [shape=box];
    load_balancer [shape=box];
    ingress [shape=box];
  }
  load_balancer, dns_manager, cert_manager -> ingress;
}
---------------------------------------------------------------------

["graphviz", "main_scheme_legend_", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  service [shape=diamond,label="Наши сервисы"];
  side_service [shape=box, label="Сторонние сервисы"];
}
---------------------------------------------------------------------

[.notes]
--
Разумеется, абстрактная схема выглядит весьма отстраненно от происходящего на самом деле.
Современные реалии обязывают нас применять шифрование, поэтому без ssl в наше время никуда.
Кроме того, если клиентов становится много, то нужно каким-то образом масштабироваться и
балансироваться. А чтобы не отдавать клиенту сухие цифры IP-адреса, то надо научиться
пользоваться еще и DNS.
--

=== А что, собственно, деплоим?
["graphviz", "main_scheme_3", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  rankdir = LR;
  source [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled,height=1.5,label="Исходный \nсайт"];
  spectator [shape=polygon,sides=5,peripheries=3,color=orange,style=filled,height=1.5,label="Пользователь"];

  source -> service_1;
  service_1 -> redis -> service_1;
  service_2 -> redis -> service_2;
  service_1 -> kafka;
  service_3 -> kafka -> service_3;
  kafka -> service_4;

  service_4 -> ingress;
  ingress -> spectator;

  subgraph mainline {
    label = "Main line";
    service_1 [shape=diamond];
    service_2 [shape=diamond];
    service_3 [shape=diamond];
    service_4 [shape=diamond];
  }

  subgraph side_services {
    label = "Side services";
    rank = same;
    redis [shape=box]
    kafka [shape=box]
  }

  subgraph support {
    label = "Support";
    rank = same;
    dns_manager [shape=box];
    cert_manager [shape=box];
    load_balancer [shape=box];
    ingress [shape=box];
  }
  load_balancer, dns_manager, cert_manager -> ingress;

  subgraph service {
    label = "Service";
    rank = same;
    logs [shape=box];
    metrics [shape=box];
  }
  logs, metrics -> ingress;
}
---------------------------------------------------------------------

["graphviz", "main_scheme_legend_", "png"]
---------------------------------------------------------------------
digraph main {
  node [fontname = "PT Sans", fontsize=20];
  edge [fontname = "PT Sans", fontsize=20];
  service [shape=diamond,label="Наши сервисы"];
  side_service [shape=box, label="Сторонние сервисы"];
}
---------------------------------------------------------------------

[.notes]
--
Но и этого, обычно, недостаточно. Мы же, как и все разработчики, хотим
иметь представление о том, что происходит. Мы хотим собирать логи и метрики
с наших сервисов, чтобы быстро находить и устранять неполадки. А еще метрики
с красивыми диаграмками и графиками очень нравятся менеджерам -
их удобно показывать заказчику. Примерно так выглядит финальная схема нашего
продукта уже с позиции инженера.
--
